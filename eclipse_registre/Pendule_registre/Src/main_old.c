/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stm32f4xx.h>
#include "delay.h"
#include "config_mcu.h"
#include "l6474.h"

#define MAX_ACCEL 5000.0
#define MAX_VITESSE 500.0
// valeur min_arr_reload et max_arr_reload depende de la vitesse donc on doit pouvoir les fixer a partir de Max_vitesse
#define MIN_ARR_RELOAD 25000 //4200
#define MAX_ARR_RELOAD 8e6
#define TIMEOUT 500

void TEST_Low(void);
void TEST_High(void);
void send_mesure_uart();
void faire_commandePC();

volatile unsigned char trame_pc_complete=0,marche=0,mode=0,cmd_traitee=1;
volatile unsigned char rx_data[33];
volatile unsigned long time_2ms=0;
volatile float reload1=MAX_ARR_RELOAD,reload2;
volatile float vitesse=0,accel=0;  // vitesse en tr/min et accel en tr/min/s
volatile unsigned long valmax=2200;
volatile long position=0; // Contient la position en terme de pas si le moteur n'en a pas perdu
volatile unsigned char direction=0,cmpt=0;
//volatile float gain=0.0015,gain_d=40e-5,gain_i=10e-9;
volatile float gain=1.1,gain_d=0.04,gain_i=10e-9;
volatile float erreur=0,erreur_av=0,e_rotor,kp_rotor=-1e-3,erreur_int,erreur_dev;
volatile float mes_angle;
volatile float kp_teta,kp_psy,ki_teta,ki_psy,kd_teta,kd_psy;
float consigne =12000;

// Interruption pour horloge step du moteur pas a pas
void TIM5_IRQHandler(void)
{
	// Handle a timer 'update' interrupt event
	if (TIM5->SR & TIM_SR_UIF) {
		TIM5->SR &= ~(TIM_SR_UIF);
		// Toggle the STEP output pin.
		GPIOC->BSRR |= (1<<7);
		// Les delais NOP sont important car le l6474 a des timing plus lent que le STM32F4
		asm volatile ("NOP");
		asm volatile ("NOP");
		// On calcule la nouvelle position
		if(direction)
		{
			position++;
		}
		else
		{
			position--;
		}
		GPIOC->BSRR |= (1<<7)<<16;
		__asm__("nop");
		asm volatile("nop");
		asm volatile("nop");
		asm volatile("nop");
		__asm__("nop");
	}
}

// Interruption pour Tech boucle de calcul de la regulation
void TIM1_UP_TIM10_IRQHandler(void)
{
	unsigned long reload_long;
	time_2ms++;
	// Handle a timer 'update' interrupt event
	if (TIM10->SR & TIM_SR_UIF) {
		TIM10->SR &= ~(TIM_SR_UIF);
		if (cmpt>=MOY_FILT) // on fait 10 mesures qu'on ne moyenne pas
		{
			cmpt=0;
			erreur=consigne-mes_angle;
			erreur_int+=erreur;
			accel=gain*erreur+gain_d*(erreur-erreur_av)/(2e-3);//+erreur_int*gain_i;
			erreur_av=erreur;
			if (accel>MAX_ACCEL)
			{
				accel=MAX_ACCEL;
			}
			else if (accel<-MAX_ACCEL)
			{
				accel=-MAX_ACCEL;
			}
			//calcul vitesse
			vitesse=vitesse + accel /((float)FECH);
			// calcul rechagement si consigne vitesse
			//		erreur_int+=erreur;
			//		erreur_dev=erreur-erreur_av;
			//		vitesse=gain*erreur+gain_d*(erreur_dev)+gain_i*erreur_int;
			if (vitesse> MAX_VITESSE)
				vitesse= MAX_VITESSE;
			else if (vitesse< -MAX_VITESSE)
				vitesse= -MAX_VITESSE;
			//		erreur_av=erreur;
			//		reload2=FOSC/(200*16*(vitesse));//+0.001));  //+0.001 pour pas que ARR = 0xFFFFFFFF => bloque commande
			if(vitesse>0)
			{
				DIR_High();
				direction=1;
				reload1=(float)FOSC*60.0/(200.0*16.0*vitesse);
			}
			else
			{
				DIR_Low();
				direction=0;
				if (vitesse==0.0) vitesse=-0.001;
				reload1=(float)FOSC*60.0/(200.0*16.0*-vitesse);
			}
			//		 calcul du rechargement si consigne accelleration
//			if (accel<0) accel = -accel;
//			reload2=((float)FECH*(float)FOSC*reload1)/((float)FECH*(float)FOSC+200.0*16.0*accel*reload1);
//			if (reload2 > MAX_ARR_RELOAD)
//			{
//				reload2 = MAX_ARR_RELOAD;
//			}
//			else if (reload2 < MIN_ARR_RELOAD)
//			{
//				reload2 = MIN_ARR_RELOAD;
//			}
//			reload1=reload2;
//			reload_long=(unsigned long)reload2;
			reload_long=(unsigned long)reload1;
			if(reload_long<MIN_ARR_RELOAD)
				reload_long=MIN_ARR_RELOAD;
			else if (reload_long>MAX_ARR_RELOAD)
				reload_long=MAX_ARR_RELOAD;
			TIM5->ARR=reload_long;
			//send_mesure_uart();
			mes_angle=0;
		}
		cmpt++;
		mes_angle+=(float)TIM3->CNT;
	}
}

// Override the 'write' clib method to implement 'printf' over UART.
int main(void)
{
	//unsigned char tab[4];
	unsigned char flag=0;

	SystemInit();
	config_pendule();
	Cs_High();

	systick_init_ms(FOSC);
	TIM3->CNT=0;

	Reset_High();
	//ttmmpp=L6474_GetCONFIG();
	//curr=L6474_GetTVAL();
	L6474_SetCurrent(0.8);
	L6474_SetStepSize(16);
	L6474_Enable();
	accel=0;
	vitesse=0;
	TIM5->CR1  &= ~TIM_CR1_CEN;
	while(1)
	{   // Il y a t'il des commande a traiter ?
		if(trame_pc_complete==1)
		{
			faire_commandePC();
			flag=0;
		}
		//machine etat fonctionnement:
		if ((marche==1)&&(flag==0))
		{
			cmd_traitee=1;
			reload1=MAX_ARR_RELOAD;
			reload2=MAX_ARR_RELOAD;
			erreur_av=0;
			erreur_int=0;
			accel=0;
			vitesse=0;
			position=0;
			if (flag==0)
			{
				TIM3->CNT=0;
				printf( "cod: %ld \r\n",TIM3->CNT);
				flag=1;
				L6474_Enable();
				// Enable the hardware interrupt.
				TIM5->CR1  |= TIM_CR1_CEN;
				erreur_int=0;
				mes_angle=0;
			}
		}
		else
		{
				// Disable the hardware interrupt.
				L6474_Disable();
				TIM5->CR1  &= ~TIM_CR1_CEN;
		}
			//delay_ms(10);
	}
		//L6474_GetStatus(rxb);
		//printf( "cod: %ld  acc: %f vitesse: %f ARR: %ld \r\n",TIM3->CNT,accel,vitesse,TIM5->ARR);
		//delay_ms(200);
		//send_mesure_uart();9
}

void TEST_High(void)
{
	GPIOC->BSRR |= (1<<8);
}

void TEST_Low(void)
{
	GPIOC->BSRR |= (1<<8)<<16;
}

//Reception par ISR
void USART2_IRQHandler()
{
	static char i=0,rcv_begin;
	unsigned char tmp_char;
	static unsigned long debut;
	unsigned long dummy;
	/* Check if enabled interrupt source is active */
	if (USART2->SR & USART_SR_RXNE)
	{
		/* Clear interrupt source */
		tmp_char=USART2->DR;
		if((tmp_char=='?')&&(rcv_begin==0))
		{
			rcv_begin=1;
			debut=time_2ms;
			i=0;
		}
		if((rcv_begin==1)&&((time_2ms-debut)<TIMEOUT))
		{
			if(i<7)
			{
				if(i==0)
				{
				}
				else
				{
					rx_data[i-1]=tmp_char;
				}
				i++;
			}
			else if((i==7)&&(tmp_char=='!'))
			{
				trame_pc_complete=1;
				i=0;
				rcv_begin=0;
			}
			else
			{
				rcv_begin=0;
				//  trame_pc_complete=0;
				i=0;
			}
		}
		else
		{
			rcv_begin=0;
			//   trame_pc_complete=0;
			i=0;
		}
	}
	/* Overrun */
	else if(USART2->SR & USART_SR_ORE)
	{
		dummy = USART2->SR;
		dummy = USART2->DR;
		rcv_begin=0;
		i=0;
	}
}

void faire_commandePC()
{
	float *tmpf;
	void *tmpv;
	tmpv=rx_data+2;
	tmpf=tmpv;
    switch (rx_data[0])
    {
        case 'S':
        // mode START/STOP + mode regul
        	if (rx_data[1]=='1')
        	{ // Marche TP
        		marche=1;
        		if(rx_data[2]=='1')
        		{ // Regul Teta PID
        			mode=1;
        		}
        		else if(rx_data[2]=='2')
        		{ // Regul Teta PID + Psy PID
        			mode=2;
        		}
        		else if(rx_data[2]=='3')
        		{ // Regul Teta PID + Psy RST
        			mode=3;
        		}
        		else
        		{ // Boucle ouvert Identification
        			mode=0;
        		}
        	}
        	else
        	{
        		marche=0;
        		mode=0;
    		}
        break;
        case 'D':
        //mode Demo
		if (rx_data[1]=='1')
		{	// Marche Demo
			marche=1;
			mode=4;
		}
		else
		{
			marche=0;
			mode=0;
    	}
		break;
        case 'C':
        // Consigne
        	/*---------------------------- A FAIRE --------------
        	 *
        	 ---------------------------------------------------*/
        break;
        case 'M':
        // Config Mesure a retourne
        	/*---------------------------- A FAIRE --------------
        	 *
        	 ---------------------------------------------------*/
        break;
        case 'p':
        // Coeff  Prop PID
        	if (rx_data[1]=='0')
        	{ // Teta
        		kp_teta=*tmpf;
        	}
        	else
        	{ // Psy
        		kp_psy=*tmpf;
        	}
        break;
        case 'i':
        // Coeff Int PID
        	if (rx_data[1]=='0')
        	{ // Teta
        		ki_teta=*tmpf;
        	}
        	else
        	{ // Psy
        		ki_psy=*tmpf;
        	}
        break;
        case 'd':
        // coeff Deriv PID
        	if (rx_data[1]=='0')
        	{ // Teta
        		kd_teta=*tmpf;
        	}
        	else
        	{ // Psy
        		kd_psy=*tmpf;
        	}
        break;
        case 'r':
        // Coeff polynome R
        break;
        case 's':
        // Coeff polynome S
        break;
        case 't':
        // Coeff polynome T
        break;
        default:
        break;
    }
    trame_pc_complete=0;
}




void send_mesure_uart()
{
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = '#';
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 'M';
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x32;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x33;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x34;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x35;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x36;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x37;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x38;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x39;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3A;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3B;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3C;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3D;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3E;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = '\n';
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = '\r';
}
