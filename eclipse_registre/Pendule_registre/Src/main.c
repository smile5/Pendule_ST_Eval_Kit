/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stm32f4xx.h>
#include "delay.h"
#include "config_mcu.h"
#include "l6474.h"
#include "signaux.h"

#define MAX_ACCEL 500.0f //5000.0

// valeur PID pour demo : Kteta=1.21 Titeta= infini Td teta=0.05 Kpsy=0.15 Tipsy=10 Tdpsy=0.8

// valeur min_arr_reload et max_arr_reload depende de la vitesse donc on doit pouvoir les fixer a partir de Max_vitesse
#define MIN_ARR_RELOAD 18750 //25000 //4200
#define MAX_VITESSE 84.0f   //60*FOSC/(200.0*16.0*MIN_ARR_RELOAD)
#define MAX_ARR_RELOAD 8000000
#define TIMEOUT 500
#define TECH 0.002f
#define FECH 500
#define N_PSY (10.0f)
#define VERTICAL 12000.0f

void TEST_Low(void);
void TEST_High(void);
void send_mesure_uart_dma();
void send_mesure_uart();
void faire_commandePC();
void calcul_coeff_rec_teta();
void calcul_coeff_rec_psy();
void construction_tab();
void swing();

volatile unsigned char trame_pc_complete=0,marche=0,mode=0;
volatile unsigned char rx_data[33];
volatile unsigned long time_2ms=0,time=0;
volatile float reload1=MAX_ARR_RELOAD;
volatile float vitesse=0,accel=0,accel2=0;  // vitesse en tr/min et accel en tr/min/s
volatile long position_psy=0; // Contient la position en terme de pas si le moteur n'en a pas perdu
volatile unsigned char direction=0,cmpt_filt=0,cmpt_psy=0;
volatile float mes_angle,erreur_int_psy,erreur_int_teta;
volatile float kp_teta,kp_psy,ki_teta,ki_psy,kd_teta,kd_psy;
volatile float ti_teta,ti_psy,td_teta,td_psy;
float consigne_psy=0.0f;
float lam_teta;
float coef_rec_e_teta[8]={0,0,0,0,0,0,0},coef_rec_s_teta[8]={0,0,0,0,0,0,0};
volatile float val_s_teta[8]={0,0,0,0,0,0,0},val_e_teta[8]={0,0,0,0,0,0,0}; // contient les valeur de S et E pour la reccurence
float coef_rec_e_psy[8]={0,0,0,0,0,0,0},coef_rec_s_psy[8]={0,0,0,0,0,0,0};
volatile float val_s_psy[8]={0,0,0,0,0,0,0},val_e_psy[8]={0,0,0,0,0,0,0}; // contient les valeur de S et E pour la reccurence
volatile float tab_deriv[8]={0,0,0,0,0,0,0};
extern unsigned char tab_dma[20];
volatile const float *pointeur_gen;
volatile float saut_index=1,amplitude=0;

// Interruption pour horloge step du moteur pas a pas
void TIM5_IRQHandler(void)
{
	// Handle a timer 'update' interrupt event
	if (TIM5->SR & TIM_SR_UIF) {
		TIM5->SR &= ~(TIM_SR_UIF);
		// Toggle the STEP output pin.
		GPIOC->BSRR |= (1<<7);
		// Les delais NOP sont important car le l6474 a des timing plus lent que le STM32F4
		asm volatile ("NOP");
		asm volatile ("NOP");
		// On calcule la nouvelle position
		if(direction)
		{
			position_psy++;
		}
		else
		{
			position_psy--;
		}
		GPIOC->BSRR |= (1<<7)<<16;
		__asm__("nop");
		asm volatile("nop");
		asm volatile("nop");
		asm volatile("nop");
		__asm__("nop");
	}
}

// Interruption pour Tech boucle de calcul de la regulation
void TIM1_UP_TIM10_IRQHandler(void)
{
	unsigned long reload_long;
	float deriv_f;
	time_2ms++;
	// Handle a timer 'update' interrupt event
	if (TIM10->SR & TIM_SR_UIF)
	{
		TIM10->SR &= ~(TIM_SR_UIF);
		if (cmpt_filt>=MOY_FILT) // on fait 10 mesures qu'on ne moyenne pas
		{
			//TEST_Low();
			cmpt_filt=0;
			if(mode==2) // PID sur PSY
			{
				if(cmpt_psy>=(unsigned char)N_PSY)
				{	//imaginer limiteur d'integral ?
					cmpt_psy=0;
					val_e_psy[0]=consigne_psy-position_psy;
					//PD simple
					//erreur_int_psy+=val_e_psy[0]*TECH*N_PSY;
					//val_s_psy[0]=kp_psy*(val_e_psy[0]+td_psy*((val_e_psy[0]-val_e_psy[1])/(N_PSY*TECH))+ erreur_int_psy/ti_psy);
					// Euler
					val_s_psy[0]=coef_rec_s_psy[1]*val_s_psy[1]+coef_rec_e_psy[0]*val_e_psy[0]+coef_rec_e_psy[1]*val_e_psy[1]+coef_rec_e_psy[2]*val_e_psy[2];
					// sauvegarde valeurs d'avant
					val_e_psy[2]=val_e_psy[1];
					val_e_psy[1]=val_e_psy[0];
					val_s_psy[2]=val_s_psy[1];
					val_s_psy[1]=val_s_psy[0];
				}
			}
			else if (mode==3) // RST sur PSY
			{

			}
			else if(mode==0) // boucle ouverte faut voir ce qu'on fait
			{

			}
			else // simple boucle consigne fixe
			{
				val_s_psy[0]=0.0f;
			}
			if(mode!=0) // regul sur Teta et consigne calculer juste avant
			{
				cmpt_psy++;
				val_e_teta[0]=VERTICAL-mes_angle;
				tab_deriv[0]=val_e_teta[0]-val_e_teta[1];
				deriv_f=(tab_deriv[0]+tab_deriv[1]+tab_deriv[2])/(3.0f * TECH);
				tab_deriv[2]=tab_deriv[1];
				tab_deriv[1]=tab_deriv[0];
				erreur_int_teta+=val_e_teta[0]*TECH;
				// avec Derive simpliste XG
				accel=kp_teta*(val_e_teta[0]+td_teta*(deriv_f)); //+erreur_int_teta/ti_teta);
				// avec equation de recurrence Euler
				//accel2=coef_rec_s_teta[2]*val_s_teta[2]+coef_rec_s_teta[1]*val_s_teta[1]+coef_rec_e_teta[0]*val_e_teta[0]+coef_rec_e_teta[1]*val_e_teta[1]+coef_rec_e_teta[2]*val_e_teta[2];
				//Limitation acceleration
				val_s_teta[0]=accel;
				// sauvegarde valeurs d'avant
				val_e_teta[2]=val_e_teta[1];
				val_e_teta[1]=val_e_teta[0];
				val_s_teta[2]=val_s_teta[1];
				val_s_teta[1]=val_s_teta[0];
				val_s_teta[0]=accel-val_s_psy[0];
				if (val_s_teta[0]>MAX_ACCEL) //||(accel==inf))
				{
					val_s_teta[0]=MAX_ACCEL;
				}
				else if (val_s_teta[0]<-MAX_ACCEL) //||(accel==-inf))
				{
					val_s_teta[0]=-MAX_ACCEL;
				}
				//calcul vitesse
				vitesse=vitesse + val_s_teta[0] *TECH;
				//Limitation vitesse
				if (vitesse> MAX_VITESSE)
					vitesse= MAX_VITESSE;
				else if (vitesse< -MAX_VITESSE)
					vitesse= -MAX_VITESSE;
				if(vitesse>0)
				{
					DIR_High();
					direction=1;
					reload1=(float)FOSC*60.0/(200.0*16.0*vitesse);
				}
				else
				{
					DIR_Low();
					direction=0;
					if (vitesse==0.0) vitesse=-0.001;
					reload1=(float)FOSC*60.0/(200.0*16.0*-vitesse);
				}
				reload_long=(unsigned long)reload1;
				if(reload_long<MIN_ARR_RELOAD)
					reload_long=MIN_ARR_RELOAD;
				else if (reload_long>MAX_ARR_RELOAD)
					reload_long=MAX_ARR_RELOAD;
				TIM5->ARR=reload_long;
			}
			construction_tab();
			send_mesure_uart_dma();
			mes_angle=0;
			//TEST_High();
			// calcul consigne uniquement pour mode 2 et 3
			//calcul index tableau signal
			time++;
			consigne_psy=(*(pointeur_gen+(unsigned short)(saut_index*time))*amplitude)*(200.0f*16.0f/360.0f);
			if(saut_index*time>512)
				time=0;
		}
		cmpt_filt++;
		mes_angle+=(float)(TIM3->CNT)-2400.0;
	}
}

int main(void)
{
	unsigned char flag=0;
	SystemInit();
	config_pendule();
	Cs_High();
	systick_init_ms(FOSC);
	TIM3->CNT=4*NPT_CODEUR;
	Reset_High();
	//ttmmpp=L6474_GetCONFIG();
	//curr=L6474_GetTVAL();
	L6474_SetCurrent(0.8);
	L6474_SetStepSize(16);
	L6474_Enable();
	accel=0;
	vitesse=0;
	marche=0;
	pointeur_gen=triangle;
	TIM5->CR1  &= ~TIM_CR1_CEN;
	TIM10->CR1  &= ~TIM_CR1_CEN;
//	swing();
	while(1)
	{   // Il y a t'il des commande a traiter ?
		if(trame_pc_complete==1)
		{
			faire_commandePC();
			flag=0;
		}
		//machine etat fonctionnement:
		if ((marche==1)&&(flag==0))
		{
			reload1=MAX_ARR_RELOAD;
			val_s_teta[0]=0;
			val_s_teta[1]=0;
			val_s_teta[2]=0;
			val_e_teta[0]=0;
			val_e_teta[1]=0;
			val_e_teta[2]=0;
			val_s_psy[0]=0;
			val_s_psy[1]=0;
			val_s_psy[2]=0;
			val_e_psy[0]=0;
			val_e_psy[1]=0;
			val_e_psy[2]=0;
			cmpt_filt=0;
			accel=0;
			accel2=0;
			vitesse=0;
			position_psy=0;
			erreur_int_psy=0;
			erreur_int_teta=0;
			time=0;
			consigne_psy=0;
			mes_angle=0;
			if (flag==0)
			{
				TIM3->CNT=4*NPT_CODEUR;
				//printf( "cod: %ld \r\n",TIM3->CNT);
				flag=1;
				if((mode==1)||(mode==2))
				{
					L6474_Enable();
					// Enable the hardware interrupt.
					delay_ms(4000);
					TIM5->CR1  |= TIM_CR1_CEN;
					TIM10->CR1  |= TIM_CR1_CEN;
				}
				else
				{
					L6474_Disable();
					TIM10->CR1  |= TIM_CR1_CEN;
					TIM5->CR1  &= ~TIM_CR1_CEN;
				}
				mes_angle=0;
			}
		}
		else if (marche == 0)
		{
				// Disable the hardware interrupt.
				L6474_Disable();
				TIM5->CR1  &= ~TIM_CR1_CEN;
				TIM10->CR1  &= ~TIM_CR1_CEN;
		}
	}
}

void TEST_High(void)
{
	GPIOC->BSRR |= (1<<3);
}

void TEST_Low(void)
{
	GPIOC->BSRR |= (1<<3)<<16;
}

//Reception par ISR
void USART2_IRQHandler()
{
	static char i=0,rcv_begin;
	unsigned char tmp_char;
	static unsigned long debut;
	unsigned long dummy;
	/* Check if enabled interrupt source is active */
	if (USART2->SR & USART_SR_RXNE)
	{
		/* Clear interrupt source */
		tmp_char=USART2->DR;
		if(((tmp_char=='?')||(tmp_char=='#'))&&(rcv_begin==0))
		{
			rcv_begin=1;
			debut=time_2ms;
			i=0;
		}
		if((rcv_begin==1)&&((time_2ms-debut)<TIMEOUT))
		{
			if(i<7)
			{
				if(i==0)
				{
				}
				else
				{
					rx_data[i-1]=tmp_char;
				}
				i++;
			}
			else if((i==7)&&((tmp_char=='!')||(tmp_char=='$')))
			{
				trame_pc_complete=1;
				i=0;
				rcv_begin=0;
			}
			else
			{
				rcv_begin=0;
				//  trame_pc_complete=0;
				i=0;
			}
		}
		else
		{
			rcv_begin=0;
			//   trame_pc_complete=0;
			i=0;
		}
	}
	/* Overrun */
	else if(USART2->SR & USART_SR_ORE)
	{
		dummy = USART2->SR;
		dummy = USART2->DR;
		rcv_begin=0;
		i=0;
	}
}

void faire_commandePC()
{
	float *tmpf;
	void *tmpv;
	tmpv=rx_data+2;
	tmpf=tmpv;
	switch (rx_data[0])
	{
	case 'S':
		// mode START/STOP + mode regul
		if (rx_data[1]=='1')
		{ // Marche TP
			marche=1;
			if(rx_data[2]=='1')
			{ // Regul Teta PID
				mode=1;
			}
			else if(rx_data[2]=='2')
			{ // Regul Teta PID + Psy PID
				mode=2;
			}
			else if(rx_data[2]=='3')
			{ // Regul Teta PID + Psy RST
				mode=3;
			}
			else
			{ // Boucle ouvert Identification
				mode=0;
			}
		}
		else
		{
			marche=0;
			mode=0;
		}
		break;
	case 'D':
		//mode Demo
		if (rx_data[1]=='1')
		{	// Marche Demo
			marche=1;
			mode=2;
			//ici faire balencement automatique et gestion consigne
			// puis valider les ISR pour la Regul
			pointeur_gen=carree;
			saut_index=512.0f * TECH / 30.0;
			amplitude=120.0/360.0;
			swing(); // fonction bloquante qui sort qd le bras est an haut
		}
		else
		{
			marche=0;
			mode=0;
		}
		break;
	case 'C':
		// Consigne
		if(rx_data[1]=='1')
		{  //Gestion forme
			switch (rx_data[2])
			{
			case 0:
				pointeur_gen=carree;
				break;
			case 1:
				pointeur_gen=triangle;
				break;
			case 2:
				pointeur_gen=sinus;
				break;
			case 4:
				pointeur_gen=echelon;
				break;
			case 3:
				pointeur_gen=scie;
				break;
			default:
				pointeur_gen=sinus;
				break;
			}
		}
		else if(rx_data[1]=='2')
		{ // Gestion frequence
			float test;
			test=*tmpf;
			saut_index=512.0f * TECH / test;
		}
		else if(rx_data[1]=='3')
		{ // gestion amplitude
			amplitude=*tmpf;
		}
		break;
	case 'M':
		// Config Mesure a retourne
		/*---------------------------- A FAIRE --------------
		 *
        	 ---------------------------------------------------*/
		break;
	case 'p':
		// Coeff  Prop PID
		if (rx_data[1]=='0')
		{ // Teta
			kp_teta=*tmpf;
			calcul_coeff_rec_teta();
		}
		else
		{ // Psy
			kp_psy=*tmpf;
			calcul_coeff_rec_psy();
		}
		break;
	case 'i':
		// Coeff Int PID
		if (rx_data[1]=='0')
		{ // Teta
			ti_teta=*tmpf;
			calcul_coeff_rec_teta();
		}
		else
		{ // Psy
			ti_psy=*tmpf;
			calcul_coeff_rec_psy();
		}
		break;
	case 'd':
		// coeff Deriv PID
		if (rx_data[1]=='0')
		{ // Teta
			td_teta=*tmpf;
			calcul_coeff_rec_teta();
		}
		else
		{ // Psy
			td_psy=*tmpf;
			calcul_coeff_rec_psy();
		}
		break;
	case 'r':
		// Coeff polynome R
		break;
	case 's':
		// Coeff polynome S
		break;
	case 't':
		// Coeff polynome T
		break;
	default:
		break;
	}
	trame_pc_complete=0;
}

void calcul_coeff_rec_teta()
{
	//PID FILTRE
//	lam_teta=0.1;
//	ki_teta=0; //kp_teta/ti_teta;
//	kd_teta=kp_teta*td_teta;
//	coef_rec_e_teta[0]=(lam_teta*TECH*TECH*ki_teta+lam_teta*kd_teta+lam_teta*kp_teta*TECH+ki_teta*td_teta*TECH+kd_teta)/(td_teta+lam_teta*TECH);
//	coef_rec_e_teta[1]=-(2*kd_teta*(1+lam_teta)+lam_teta*kp_teta*TECH+ki_teta*td_teta*TECH)/(td_teta+lam_teta*TECH);
//	coef_rec_e_teta[2]=(kd_teta*(1+lam_teta))/(td_teta+lam_teta*TECH);
//	coef_rec_s_teta[0]=1;
//	coef_rec_s_teta[1]=(lam_teta+2*td_teta)/(td_teta+lam_teta*TECH);
//	coef_rec_s_teta[2]=-(td_teta/(td_teta+lam_teta*TECH));
	//PID NON FILTRE
//
	ki_teta=kp_teta/ti_teta;
	kd_teta=kp_teta*td_teta;
	coef_rec_e_teta[0]=kp_teta+ki_teta*TECH+kd_teta/TECH;
	coef_rec_e_teta[1]=-kp_teta-2.0*kd_teta/TECH;
	coef_rec_e_teta[2]=kd_teta/TECH;
	coef_rec_s_teta[0]=0.0;
	coef_rec_s_teta[1]=1.0;
	coef_rec_s_teta[2]=0.0;

}
void calcul_coeff_rec_psy()
{
	ki_psy=kp_psy/ti_psy;
	//ki_psy=0;
	kd_psy=kp_psy*td_psy;
	coef_rec_e_psy[0]=kp_psy+ki_psy*(N_PSY*TECH)+kd_psy/(N_PSY*TECH);
	coef_rec_e_psy[1]=-kp_psy-2.0*kd_psy/(N_PSY*TECH);
	coef_rec_e_psy[2]=kd_psy/(N_PSY*TECH);
	coef_rec_s_psy[0]=0.0;
	coef_rec_s_psy[1]=1.0;
	coef_rec_s_psy[2]=0.0;
}

inline void construction_tab()
{
	short tmp;
	unsigned char *p;
	/* Construction Tableau a envoyer */
	//tmp=24000.0*accel/360.0;
	p=&mes_angle;
	tab_dma[1]=*p;
	tab_dma[2]=*(p+1);
	tab_dma[3]=*(p+2);
	tab_dma[4]=*(p+3);
	//tmp=(long)(mes_angle);
	p=&position_psy; //on le transforme en 24 bits pour gagner temps sur transmission
	tab_dma[5]=*(p);
	tab_dma[6]=*(p+1);
	tab_dma[7]=*(p+2);
	tmp=(short) (consigne_psy);
	p=&tmp; // attention visiblement consigne est un float
	tab_dma[8]=*p;
	tab_dma[9]=*(p+1);
	p=&val_s_teta[0];
	tab_dma[10]=*p;
	tab_dma[11]=*(p+1);
	tab_dma[12]=*(p+2);
	tab_dma[13]=*(p+3);
	p=&val_s_psy[0];
	tab_dma[14]=*p;
	tab_dma[15]=*(p+1);
	tab_dma[16]=*(p+2);
	tab_dma[17]=*(p+3);
}

void send_mesure_uart_dma()
{
	DMA1->HIFCR = DMA_HIFCR_CTCIF6 | DMA_HIFCR_CHTIF6 | DMA_HIFCR_CTEIF6 | DMA_HIFCR_CDMEIF6 | DMA_HIFCR_CFEIF6; // clear DMA flags
//	DMA1_Stream6->M0AR = &tab_dma;
//	DMA1_Stream6->NDTR=20;
	DMA1_Stream6->CR |= 1; // Enable tranfert
}

void swing()
{
	float angle=0,angle2=0;
	unsigned short dir=0;
	//init
	TIM3->CNT=4*NPT_CODEUR;
	reload1=MAX_ARR_RELOAD;
	L6474_Enable();
	// Enable the hardware interrupt.
	TIM5->CR1  |= TIM_CR1_CEN;
	TIM10->CR1  &= ~TIM_CR1_CEN;
	//TIM10->CR1  |= TIM_CR1_CEN;
	while( (angle>1233.0f) || (angle<1166.0f))
	{

		if((angle>-100.0f)&&(angle<100.0f)&&(dir==1))
		{
			TIM5->CR1  |= TIM_CR1_CEN;
			DIR_Low();
			TIM5->ARR=33000;
			delay_ms(100);
			TIM5->CR1  &= ~TIM_CR1_CEN;
			dir=0;
		}
			else if ((angle>-100.0f)&&(angle<100.0f)&&(dir==0))
		{
			TIM5->CR1  |= TIM_CR1_CEN;
			DIR_High();
			TIM5->ARR=33000;
			delay_ms(100);
			TIM5->CR1  &= ~TIM_CR1_CEN;
			dir=1;
		}
			else
			delay_ms(2);

		angle=(float)(TIM3->CNT)-2400.0f;

		//angle=(float)(TIM3->CNT)-2400.0f;

	}
	val_s_teta[0]=0;
	val_s_teta[1]=0;
	val_s_teta[2]=0;
	val_e_teta[0]=0;
	val_e_teta[1]=0;
	val_e_teta[2]=0;
	val_s_psy[0]=0;
	val_s_psy[1]=0;
	val_s_psy[2]=0;
	val_e_psy[0]=0;
	val_e_psy[1]=0;
	val_e_psy[2]=0;
	cmpt_filt=0;
	accel=0;
	accel2=0;
	vitesse=0;
	position_psy=0;
	erreur_int_psy=0;
	erreur_int_teta=0;
	time=0;
	consigne_psy=0;
	mes_angle=0;
	TIM5->CR1  |= TIM_CR1_CEN;
	TIM10->CR1  |= TIM_CR1_CEN;
}

void send_mesure_uart()
{
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = '=';
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 'M';
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x32;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x33;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x34;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x35;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x36;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x37;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x38;
	while( !( USART2->SR & USART_SR_TXE ) ) {};https://forum.arduino.cc/t/mesure-de-regime-moteur/88725/32
	USART2->DR = 0x39;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3A;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3B;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3C;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3D;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = 0x3E;
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = '\n';
	while( !( USART2->SR & USART_SR_TXE ) ) {};
	USART2->DR = '\r';
}
